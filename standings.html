<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings ‚Äì Sacred Sundays</title>
  <meta name="color-scheme" content="light dark" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header>
    <h1>üèÜ Standings</h1>
    <div class="controls">
      <button id="refresh" class="btn ghost" title="Refresh standings">‚Üª Reset Standings</button>
      <button id="exportCSV" class="btn ghost" title="Download CSV">‚¨áÔ∏è CSV</button>
<div class="controls">
  <button id="viewToggle" class="btn ghost">üñ•Ô∏è Desktop View</button>
</div>

    </div>
    <div class="controls">
      <button id="darkModeToggle" class="btn" aria-pressed="false">üåô Toggle Dark Mode</button>
    </div>
  </header>

  <main>
    <section class="card">
      <div class="toolbar">
        <span class="status" id="status"><span class="dot" aria-hidden="true"></span> Loading standings‚Ä¶</span>
        <span class="legend" aria-hidden="true">
          <span class="chip"><i class="win-i"></i> Win</span>
          <span class="chip"><i class="loss-i"></i> Loss</span>
          <span class="chip"><span aria-hidden="true">üò¥</span> BYE indicator</span>
        </span>
      </div>

      <div class="table-wrap" id="tableWrap" role="region" aria-label="Current League Standings">
        <table id="standingsTable" aria-describedby="status">
          <colgroup></colgroup>
          <thead id="thead"></thead>
          <tbody id="tbody"></tbody>
        </table>
        <!-- Mobile cards container -->
        <div id="cards" class="cards" aria-label="Standings (mobile cards)"></div>
      </div>
    </section>
  </main>

  <footer>
    <p>&copy; 2025 Sacred Sundays League</p>
  </footer>

  <script>
/* ===================== CONFIG (edit me) ===================== */
const CONFIG = {
  apiKey: 'AIzaSyDqIFrO42J4b0faekmmEGTjKmbZ4PRGc6M',
  sheetId: '1vNjLCTxmM1c09aONXyQYpGTPwcGG-hmnflq8-ZC3Rmo',
  rangeA1: 'Standings!A1:W19',      // includes Earnings in col W
  gid: '2112652019',               // Standings tab gid (from the URL)
  resourceKey: ''                  // leave empty; only needed if your file enforces it
};
/* ============================================================ */

const qs  = (s, el=document) => el.querySelector(s);
const qsa = (s, el=document) => Array.from(el.querySelectorAll(s));

/* ---------- Logo helpers ---------- */
const LOGO_OVERRIDES = {
  // "Mike Honcho": "mike-honcho",
  // "Newport Nuquertos": "newport-nuquertos",
};
const slug = s => s.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');

function attachTeamLogo(td, teamName) {
  const base = LOGO_OVERRIDES[teamName] || slug(teamName);
  const exts = ['.png', '.svg', '.webp', '.jpg', '.jpeg'];
  const img = document.createElement('img');
  img.className = 'team-logo';
  img.alt = `${teamName} logo`;
  img.loading = 'lazy';
  img.referrerPolicy = 'no-referrer';

  let i = 0;
  const tryNext = () => {
    if (i >= exts.length) { img.style.display = 'none'; return; }
    img.src = `Images/teams/${base}${exts[i++]}`;
  };
  img.onerror = tryNext;
  tryNext();

  td.appendChild(img);
  const span = document.createElement('span');
  span.className = 'team-name';
  span.textContent = teamName;
  td.appendChild(span);
}

/* ---------- Theme ---------- */
const prefersDark  = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
const storedTheme  = localStorage.getItem('theme');
const rootEl       = document.documentElement;
function applyTheme(mode) {
  const dark = mode === 'dark' || (mode === 'auto' && prefersDark);
  rootEl.classList.toggle('dark', dark);
  qs('#darkModeToggle').setAttribute('aria-pressed', dark ? 'true' : 'false');
}
applyTheme(storedTheme || 'auto');
qs('#darkModeToggle').addEventListener('click', () => {
  const nowDark = !rootEl.classList.contains('dark');
  rootEl.classList.toggle('dark', nowDark);
  localStorage.setItem('theme', nowDark ? 'dark' : 'light');
  qs('#darkModeToggle').setAttribute('aria-pressed', nowDark ? 'true' : 'false');
});
const urlTheme = new URLSearchParams(location.search).get('theme');
if (urlTheme) { localStorage.setItem('theme', urlTheme); applyTheme(urlTheme); }

/* ---------- Skeleton while loading ---------- */
function renderSkeleton(rows = 6, cols = 12) {
  const tbody = qs('#tbody');
  tbody.innerHTML = '';
  for (let r=0; r<rows; r++) {
    const tr = document.createElement('tr');
    tr.className = 'skeleton-row';
    for (let c=0; c<cols; c++) {
      const td = document.createElement('td');
      td.textContent = '\u00A0';
      if (c===0) td.classList.add('sticky');
      if (c===1) td.classList.add('sticky','second');
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  }
}

/* ===================== DATA LOADERS ===================== */

const CACHE_KEY = 'standings-cache-v3';
const CACHE_TTL = 0 * 1000; // ms

function buildApiUrl() {
  const base = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.sheetId}/values/${encodeURIComponent(CONFIG.rangeA1)}?key=${CONFIG.apiKey}&majorDimension=ROWS`;
  return CONFIG.resourceKey ? `${base}&resourcekey=${encodeURIComponent(CONFIG.resourceKey)}` : base;
}
function buildCsvUrl() {
  // published CSV export of the Standings tab; we‚Äôll slice the range in JS
  return `https://docs.google.com/spreadsheets/d/${CONFIG.sheetId}/export?format=csv&gid=${CONFIG.gid}`;
}

// Very small CSV parser (handles quotes and commas)
function parseCSV(text) {
  const rows = [];
  let cur = '', row = [], inQ = false;
  for (let i=0; i<text.length; i++) {
    const ch = text[i], next = text[i+1];
    if (inQ) {
      if (ch === '"' && next === '"') { cur += '"'; i++; }
      else if (ch === '"') inQ = false;
      else cur += ch;
    } else {
      if (ch === '"') inQ = true;
      else if (ch === ',') { row.push(cur); cur=''; }
      else if (ch === '\n') { row.push(cur); rows.push(row); row=[]; cur=''; }
      else if (ch === '\r') { /* ignore */ }
      else cur += ch;
    }
  }
  row.push(cur);
  rows.push(row);
  return rows;
}

// Convert range "A1:W19" -> number of columns (A..W => 23)
function colsFromRange(r) {
  const m = /:([A-Z]+)\d+/i.exec(r);
  if (!m) return 23;
  const letters = m[1].toUpperCase();
  // convert base-26 letters to number
  let n = 0;
  for (const c of letters) n = n*26 + (c.charCodeAt(0)-64);
  return n;
}
// Convert range -> number of rows (1..19 => 19)
function rowsFromRange(r) {
  const m = /:(?:[A-Z]+)(\d+)/i.exec(r);
  return m ? parseInt(m[1],10) : 19;
}

async function getStandings() {
  const now = Date.now();
  try {
    const cached = JSON.parse(localStorage.getItem(CACHE_KEY) || 'null');
    if (cached && (now - cached.time) < CACHE_TTL) {
      console.log('[cache] using cached data');
      return cached.data;
    }
  } catch {}

  // 1) Try Sheets API
  try {
    const apiUrl = buildApiUrl() + `&_=${Date.now()}`;
    console.log('[fetch] Sheets API ‚Üí', apiUrl);
    const res = await fetch(apiUrl, { cache: 'no-store' });
    if (!res.ok) {
      const txt = await res.text().catch(()=> '');
      console.warn('[fetch] API error', res.status, txt);
      throw { type:'api', status:res.status, body:txt };
    }
    const json = await res.json();
    if (!json.values || !json.values.length) throw { type:'api-empty' };
    try { localStorage.setItem(CACHE_KEY, JSON.stringify({ time: now, data: json })); } catch {}
    qs('#status').textContent = 'Loaded via Google Sheets API';
    return json;
  } catch (err) {
    console.warn('[fetch] API failed, falling back to CSV', err);
  }

  // 2) Fallback: Published CSV
  const csvUrl = buildCsvUrl() + `&_=${Date.now()}`;
  console.log('[fetch] CSV fallback ‚Üí', csvUrl);
  const res = await fetch(csvUrl, { cache: 'no-store' });
  if (!res.ok) {
    const txt = await res.text().catch(()=> '');
    console.error('[fetch] CSV error', res.status, txt);
    throw new Error(`CSV fallback failed (HTTP ${res.status}). ${txt}`);
  }
  const text = await res.text();
  const rows = parseCSV(text);

  const wantCols = colsFromRange(CONFIG.rangeA1);
  const wantRows = rowsFromRange(CONFIG.rangeA1);
  const trimmed = rows.slice(0, wantRows).map(r => r.slice(0, wantCols));

  // Normalize to the same JSON shape as the API
  const json = { range: CONFIG.rangeA1, majorDimension: 'ROWS', values: trimmed };
  try { localStorage.setItem(CACHE_KEY, JSON.stringify({ time: now, data: json })); } catch {}
  qs('#status').textContent = 'Loaded via CSV fallback';
  return json;
}

/* ===================== TABLE RENDER ===================== */
let currentValues = null;

function setStickyOffsets() {
  const header  = document.querySelector('header');
  const toolbar = document.querySelector('.toolbar');
  const headerH  = header ? header.offsetHeight : 0;
  const toolbarH = toolbar ? toolbar.offsetHeight : 0;
  rootEl.style.setProperty('--header-h', headerH + 'px');
  rootEl.style.setProperty('--table-sticky-top', (headerH + toolbarH) + 'px');
}
window.addEventListener('resize', setStickyOffsets);
document.addEventListener('DOMContentLoaded', setStickyOffsets);

function buildTable(values) {
  currentValues = values;
  const thead = qs('#thead');
  const tbody = qs('#tbody');
  const table = qs('#standingsTable');
  thead.innerHTML = '';
  tbody.innerHTML = '';

  const COLS = Math.max(...values.map(r => r?.length || 0));
  if (!Number.isFinite(COLS) || COLS < 3) return;

  // --- COL WIDTH PLAN (keep in sync with CSS sticky offsets)
// A = checkbox, B = team; C..P = 14 weeks; Q..(last) = summary (incl. Earnings)
const COL_A = 56;   // px
const COL_B = 220;  // px (room for long team names)
const WEEK_W = 48;  // px per week col (C..P)
const SUMM_W = 64;  // px per summary col (Q..W)

table.querySelector('colgroup')?.remove();
const cg = document.createElement('colgroup');

const colsHtml = [];

// A
colsHtml.push(`<col style="width:${COL_A}px;">`);

// B
colsHtml.push(`<col style="width:${COL_B}px;">`);

// C..P (14 week columns = indexes 2..15)
for (let i = 2; i <= 15 && i < COLS; i++) {
  colsHtml.push(`<col style="width:${WEEK_W}px;">`);
}

// Q..last (16..COLS-1) = summary columns (Win, Loss, Win%, PF, Seed, Streak, Earnings, etc.)
for (let i = 16; i < COLS; i++) {
  colsHtml.push(`<col style="width:${SUMM_W}px;">`);
}

cg.innerHTML = colsHtml.join('');
table.insertBefore(cg, thead);


  // THEAD 1: A1 message
  const trTop = document.createElement('tr');
  const thTop = document.createElement('th');
  const a1 = (values[0]?.[0] || '').toString().replace(/[\r\n]+/g, ' ').trim();
  thTop.colSpan = COLS;
  thTop.textContent = a1 || 'Standings';
  trTop.appendChild(thTop);
  thead.appendChild(trTop);

  // THEAD 2: headers
  const trHdr = document.createElement('tr');
  const headerRow = values[1] || [];
  for (let colIndex = 0; colIndex < COLS; colIndex++) {
    const th = document.createElement('th');
    th.textContent = headerRow[colIndex] ?? '';
    th.dataset.col = colIndex;
    th.classList.add('sortable'); // CSS draws arrows on sort
    if (colIndex === 16) th.classList.add('left-divider'); // col Q
    trHdr.appendChild(th);
  }
  thead.appendChild(trHdr);

  // TBODY rows
  for (let rowIndex = 2; rowIndex < values.length; rowIndex++) {
    const row = values[rowIndex] || [];
    const tr = document.createElement('tr');
    if (rowIndex === 15) tr.classList.add('divider-row');
    if (rowIndex === 7)  tr.classList.add('double-border');
    tr.dataset.rowIndex = rowIndex;

    for (let colIndex = 0; colIndex < COLS; colIndex++) {
      let cell = row[colIndex] ?? '';
      const isGameCell     = rowIndex >= 2 && rowIndex <= 14 && colIndex >= 2 && colIndex <= 15; // C..P
      const isSummaryCell  = rowIndex === 18 && colIndex >= 2 && colIndex <= 15;                 // Row 19 (Weeks summary)
      const isBlueFontCell = rowIndex === 16 && colIndex <= 15;

      const containsBye = (isGameCell || isSummaryCell) && String(cell).toUpperCase().includes('BYE');
      if (containsBye) cell = String(cell).replace(/BYE/gi, '').trim();

      let score = cell, result = '';
      if (isGameCell || isSummaryCell) {
        const up = String(cell).toUpperCase();
        if (up.includes('WIN'))  { score = isGameCell ? String(cell).replace(/WIN/gi, '').trim()  : ''; result = 'Win'; }
        if (up.includes('LOSS')) { score = isGameCell ? String(cell).replace(/LOSS/gi, '').trim() : ''; result = 'Loss'; }
      }

      const td = document.createElement('td');
      if (colIndex === 0) td.classList.add('checkbox-cell','sticky');
      if (colIndex === 1) td.classList.add('team-name-cell','sticky','second','click-highlight');
      if (colIndex === 16) td.classList.add('left-divider');
      if (isBlueFontCell || containsBye) td.classList.add('blue-font');
      if (result === 'Win')  td.classList.add('win');
      if (result === 'Loss') td.classList.add('loss');

      // Checkbox (A)
      if (colIndex === 0 && (cell === 'TRUE' || cell === 'FALSE')) {
        td.innerHTML = `<input type="checkbox" ${cell === 'TRUE' ? 'checked' : ''} disabled>`;
        tr.appendChild(td);
        continue;
      }
      // Team + logo (B)
      if (colIndex === 1) {
        const team = String(cell || '').trim();
        tr.dataset.team = team;
        attachTeamLogo(td, team);
        td.addEventListener('click', () => toggleRowHighlight(tr));
        tr.appendChild(td);
        continue;
      }
      // Game cells: score + üò¥ if BYE (hide Win/Loss text)
      if (isGameCell && (result || containsBye)) {
        const byemoji = containsBye ? ' <span title="Bye Week">üò¥</span>' : '';
        td.innerHTML = `${score || ''}${byemoji}`;
        tr.appendChild(td);
        continue;
      }
      // Row 19 summary: show Win/Loss word again
      if (isSummaryCell && result) {
        td.innerHTML = `<span class="result-label">${result}</span>`;
        tr.appendChild(td);
        continue;
      }

      td.textContent = cell;
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  }

  attachSortHandlers();
  buildCards();
  setStickyOffsets();
}

/* ---------- Sorting ---------- */
let sortState = { col: null, dir: 1 }; // 1 asc, -1 desc
function attachSortHandlers() {
  qsa('#thead tr:nth-child(2) th').forEach(th => {
    th.addEventListener('click', () => {
      const col = Number(th.dataset.col);
      if (Number.isNaN(col)) return;

      sortState = (sortState.col === col)
        ? { col, dir: -sortState.dir }
        : { col, dir: 1 };

      doSort(col, sortState.dir);
      markSortedHeader(col, sortState.dir);
      buildCards();  // reflect new order on mobile
      setStickyOffsets();
    });
  });
}
function markSortedHeader(col, dir) {
  qsa('#thead tr:nth-child(2) th').forEach(th => th.classList.remove('sorted-asc','sorted-desc'));
  const target = qs(`#thead tr:nth-child(2) th[data-col="${col}"]`);
  if (target) target.classList.add(dir === 1 ? 'sorted-asc' : 'sorted-desc');
}
function doSort(col, dir) {
  const tbody = qs('#tbody');
  const rows = Array.from(tbody.rows);
  const dividerIdx = rows.findIndex(r => r.classList.contains('divider-row'));
  const before = dividerIdx >= 0 ? rows.slice(0, dividerIdx) : rows;
  const after  = dividerIdx >= 0 ? rows.slice(dividerIdx) : [];
  const sortable = before.filter(r => !r.classList.contains('double-border'));
  sortable.sort((a, b) => {
    const A = a.cells[col]?.textContent.trim() ?? '';
    const B = b.cells[col]?.textContent.trim() ?? '';
    const nA = parseFloat(A.replace(/[% ,]/g,'')), nB = parseFloat(B.replace(/[% ,]/g,''));
    const aNum = !Number.isNaN(nA), bNum = !Number.isNaN(nB);
    if (aNum && bNum) return (nA - nB) * dir;
    return A.localeCompare(B, undefined, { numeric: true, sensitivity: 'base' }) * dir;
  });
  const newOrder = dividerIdx >= 0 ? [...sortable, ...after] : sortable;
  tbody.innerHTML = '';
  newOrder.forEach(r => tbody.appendChild(r));
}

/* ---------- Mobile Cards ---------- */
function buildCards() {
  const cards = document.getElementById('cards');
  if (!cards) return;
  cards.innerHTML = '';

  const header = (currentValues && currentValues[1]) || [];
  const dataRows = Array.from(document.querySelectorAll('#tbody tr'))
    .filter(r => !r.classList.contains('divider-row'));
  const anyRow = dataRows[0];
  const COLS = anyRow ? anyRow.cells.length : header.length;

  dataRows.forEach(tr => {
    const cells = Array.from(tr.cells);
    if (!cells.length) return;

    const teamCell = cells[1];
    const team = tr.dataset.team || (teamCell?.querySelector('.team-name')?.textContent.trim()) || 'Team';

    const isPlayoff = !!(cells[0]?.querySelector('input[type="checkbox"]')?.checked ||
                         (cells[0]?.textContent.trim().toUpperCase() === 'TRUE'));

    const card = document.createElement('article');
    card.className = 'card-row';

    const head = document.createElement('div');
    head.className = 'cr-head';
    const logo = teamCell?.querySelector('img.team-logo')?.cloneNode(true);
    if (logo) head.appendChild(logo);
    const name = document.createElement('h3');
    name.textContent = team;
    head.appendChild(name);

    if (isPlayoff) {
      const right = document.createElement('div');
      right.className = 'ml-auto';
      const chip = document.createElement('span');
      chip.className = 'chip';
      chip.title = 'Playoff team';
      chip.textContent = '‚úÖ Playoffs';
      right.appendChild(chip);
      head.appendChild(right);
    }

    const meta = document.createElement('ul');
    meta.className = 'cr-meta';
    for (let c = 16; c < COLS; c++) { // Q..end (includes Earnings W)
      const label = header[c] ?? `C${c+1}`;
      const val   = cells[c]?.textContent.trim() || '';
      const li = document.createElement('li');
      li.innerHTML = `<strong>${label}:</strong> ${val}`;
      meta.appendChild(li);
    }

    const weeks = document.createElement('div');
    weeks.className = 'cr-weeks';
    for (let c = 2; c <= 15; c++) { // C..P
      const w = document.createElement('span');
      const txt = cells[c]?.textContent.trim() || '';
      w.textContent = txt || '¬∑';
      if (cells[c]?.classList.contains('win'))  w.classList.add('w');
      if (cells[c]?.classList.contains('loss')) w.classList.add('l');
      weeks.appendChild(w);
    }

    card.appendChild(head);
    card.appendChild(meta);
    card.appendChild(weeks);
    cards.appendChild(card);
  });
}

/* ---------- Row highlight ---------- */
function toggleRowHighlight(tr) {
  const wasOn = tr.classList.contains('row-highlight');
  qsa('#tbody tr').forEach(r => r.classList.remove('row-highlight'));
  if (!wasOn) tr.classList.add('row-highlight');
}
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') qsa('#tbody tr').forEach(r => r.classList.remove('row-highlight'));
});

/* ---------- CSV Export ---------- */
function toCSV(values) {
  return values.map(r => r.map(v => {
    const s = (v ?? '').toString().replaceAll('"','""');
    return s.includes(',') || s.includes('"') || s.includes('\n') ? `"${s}"` : s;
  }).join(',')).join('\n');
}
function download(filename, text) {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([text], {type: 'text/csv'}));
  a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}

/* ===================== INIT ===================== */
let lastData = null;

async function load() {
  qs('#status').innerHTML = '<span class="dot"></span> Loading standings‚Ä¶';
  renderSkeleton();
  try {
    const json = await getStandings();
    const rows = json.values || [];
    if (!rows.length) throw new Error('No rows returned from API/CSV.');
    buildTable(rows);
    lastData = rows;

    // On mobile show sheet's date (row 2 col A); on desktop show local refresh time
    const sheetDate = (rows[1]?.[0] || '').toString().trim();
    const isMobile = window.matchMedia("(max-width: 900px)").matches;
    if (isMobile && sheetDate) {
      qs('#status').textContent = ` ${sheetDate}`;
    } else {
      qs('#status').textContent = `Last Page Refresh: ${new Date().toLocaleString()}`;
    }
  } catch (err) {
    console.error('[load] failed', err);
    const message = (err && err.message) ? err.message : 'Unknown error';
    const cols = colsFromRange(CONFIG.rangeA1) || 24;
    qs('#tbody').innerHTML =
      `<tr><td colspan="${cols}">‚ö†Ô∏è ${message} <button class="btn" id="retry">Try again</button></td></tr>`;
    qs('#status').textContent = 'Error loading.';
    qs('#retry')?.addEventListener('click', load);
  }
}

document.getElementById('refresh').addEventListener('click', () => {
  try { localStorage.removeItem(CACHE_KEY); } catch {}
  load();
});
document.getElementById('exportCSV').addEventListener('click', () => {
  if (!lastData) return;
  download('sacred-sundays-standings.csv', toCSV(lastData));
});
/* ---------- Mobile/Desktop toggle ---------- */
const viewToggle = document.getElementById('viewToggle');
if (viewToggle) {
  viewToggle.addEventListener('click', () => {
    document.body.classList.toggle('force-desktop');
    const isDesktop = document.body.classList.contains('force-desktop');
    viewToggle.textContent = isDesktop ? 'üì± Mobile View' : 'üñ•Ô∏è Desktop View';
  });
}


load();
  </script>
</body>
</html>



